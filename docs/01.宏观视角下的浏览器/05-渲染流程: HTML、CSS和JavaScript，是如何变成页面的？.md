# 渲染流程: HTML、CSS 和 JavaScript，是如何变成页面的？

## 构建 DOM 树

渲染进程无法直接理解从网络进程接收的 HTML,所以需要将 HTML 转化为渲染进程能够理解的 DOM 树;

打开浏览器开发者工具,控制台打印 `document`,查看 DOM 树;

## 样式计算

样式计算的目的是计算出 DOM 节点中每个元素的具体样式;

1. 转换 CSS 为浏览器能够理解的 styleSheets (打开浏览器开发者工具,控制台打印`document.styleSheets`,查看转换后的`styleSheets`);
2. 转换样式表中的属性值,使其标准化.  
   CSS 样式表中有很多别名,例如 `color:red;font-weight:bold;`,需要将其转换为易于渲染引擎理解的标准化计算值,`color:rgb(0,0,255);font-weight:700;`
3. 计算出每个 DOM 节点的具体样式;  
   计算 DOM 节点的具体样式,涉及到 CSS 的继承丶层叠规则和优先级;[关于 CSS 继承丶层叠规则和优先级](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance)

## 布局阶段

现在已经有 DOM 树和 DOM 树节点的具体样式,但要将页面准确的显示出来,还需要知道 DOM 节点的位置信息;那么就需要计算出 DOM 树中可见元素的位置信息,计算过程称之为布局;

1. 创建布局树  
   DOM 树中除了常见的布局元素,还有很多不可见的元素,比如 head,style,script 标签,另外还有使用 CSS 样式隐藏的元素,所以在显示之前,还需要构建一棵只包含可见元素的布局树;
2. 布局计算

## 分层

为什么分层?

页面有很多复杂效果,比如 3D 转换,页面滚动,使用`z-index`做 Z 轴排序等,为了方便实现这些效果,渲染引擎需要为特定的节点生成专用的图层,并生成对应的图层树;

如何分层?

1. 拥有[层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)的元素单独提升为一层;
2. 产生裁剪的节点也会单独创建一个图层;

## 图层绘制

完成图层树的构建之后,渲染引擎会对图层树中的图层逐个绘制!浏览器将每个图层绘制拆分为很多小的绘制指令,然后按照绘制指令的顺序生成绘制列表;最后将绘制列表输出到下一个阶段;

## 栅格化(raster: 将图块转化为位图)

绘制列表是用来记录绘制顺序和绘制指令的列表,而绘制操作是由渲染引擎中的合成线程完成的;

绘制列表生成完成后,主线程将绘制列表提交给合成线程,合成线程根据视口将图层划分为图块,并优先将视口附近的图块生成位图(实际生成位图的操作由栅格化来执行);

渲染进程维护了一个栅格化线程池,所有图块生成位图都是在栅格化线程池中进行;通常情况下,栅格化过程会使用 GPU 加速,使用 GPU 加速栅格化的过程称为快速栅格化;

## 合成和显示

所有图块都被生成位图后,合成线程会生成一个绘制图块的命令`DrawQuad`,然后将该命令提交给浏览器进程;

浏览器进程接收到合成线程的`DrawQuad`命令,根据`DrawQuad`命令,将页面内容绘制到内存中,再将内存中的内容显示在屏幕上;

## 渲染流程总结

1. 渲染引擎将 HTML 转化为渲染引擎能够理解 DOM 树;
2. 渲染引擎将 CSS 转换为渲染引擎能够理解的 StyleSheets,并计算 DOM 树每个节点的样式;
3. 渲染引擎根据 DOM 树,生成布局树,并计算布局树节点的样式信息;
4. 对布局树进行分层,创建分层树;
5. 将分层树转换为绘制列表,浏览器进程将绘制列表提交给合成进程;
6. 合成进程将图层转换为图块,并在栅格化线程池中将图块转化为位图;
7. 合成线程提交`DrawQuad`消息给浏览器进程;
8. 浏览器进程根据`DrawQuad`消息生成页面,并显示到显示器上;

![渲染流程](../images/01/render%20process.png)

## 重绘,重排和合成

[移步重绘重排和合成](../../topic/optimization/README.md)
