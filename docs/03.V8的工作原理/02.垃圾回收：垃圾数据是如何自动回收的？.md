# 垃圾回收：垃圾数据是如何自动回收的？

## 为什么需要垃圾回收

原始数据类型存储在栈空间中,引用数据类型存储在堆空间;

有些数据被使用后,就不再需要了,我们把这种数据称为垃圾数据;

垃圾数据越来越多,占用的内存越来越大,剩余的内存空间越来越小,程序运行也会越来越慢,所以我们需要对垃圾数据进行回收,释放内存空间;

## 不同语言的垃圾回收策略

两种策略:

1. 自动回收: 由内部垃圾回收系统释放内存
2. 手动回收: 由代码来分配,销毁内存

## 栈空间中的数据如何回收

```js
function foo() {
  var a = 1
  var b = { name: "极客邦" }
  function showName() {
    var c = 2
    var d = { name: "极客时间" }
  }
  showName()
}
foo()
```

![内存分配](../images/03/ram.jpg)

1. 如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。
2. 与此同时，还有一个记录当前执行状态的指针（称为 ESP），指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。
3. 当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。
4. JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。
5. showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了
6. JavaScript 引擎再创建执行上下文时,showName 内存内容会被直接覆盖掉，用来存放新创建的执行上下文。

ESP: 记录当前执行上下文的指针;

总结:栈空间中,JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。

## 堆空间中的数据如何回收

foo 函数执行完成后,ESP 指向全局执行上下文,但堆内存中仍然存储着两个对象

![内存状态](../images/03/ram_status.png)

要回收堆内存中的垃圾数据,需要使用 JavaScript 的垃圾回收器

## 垃圾回收策略

垃圾回收策略

1. 代际假说
2. 分代收集

代际假说

1. 大多对象在内存中存在时间很短,很多对象一旦分配完毕,很快就会不可访问
2. 不死的对象,存在时间很久;

分代收集

1. V8 将堆内存分为新生代和老生代两个区域
2. 新生代存放生存时间短的对象(大容量)
3. 老生代存放生存时间长的对象(通常支持 1-8M 的容量)

垃圾回收器

1. 副垃圾回收器负责新生代的垃圾回收
2. 主垃圾回收器负责老生代的垃圾回收

## 垃圾回收器的工作流程

垃圾回收执行流程

1. 标记空间中活动对象和非活动对象  
   活动对象: 存在引用的对象  
   非活动对象: 不存在引用的对象
2. 回收非活动对象占据的内存  
   标记完成后,统一回收非活动对象
3. 内存整理  
   频繁回收内存后,内存中存在大量不连续空间(内存碎片),当需要分配大量内存空间时,可能出现内存不足

## 副垃圾回收器

副垃圾回收器负责新生区的垃圾回收,使用 Scavenge 算法;

Scavenge 算法将新生区划分为两个区域,空闲区域和对象区域,新加入的对象存储在对象区域,当对象区域内存不足时,就执行一次垃圾回收;

1. 将对象区域的垃圾做标记
2. 副垃圾回收器将存活的对象复制到空闲区域并将其有序的排列
3. 将空闲区域和对象区域相互调整,对象区域变成空闲区域,空闲区域变成对象区域

Scavenge 算法的问题

每次执行垃圾回收都需要将存活的对象复制到空闲区域,复制需要时间成本,为了执行效率,新生区的空间一般比较小

新生区内存空间小,很容易内存活的对象占满,为解决这个问题,引入对象晋升策略,即经过两次垃圾回收依然存活的对象,分配到老生区中

## 主垃圾回收器

主垃圾回收器主要负责老生区的垃圾回收,存储较大的对象和新生区晋升的对象

主垃圾回收器采用`标记-清除`算法进行垃圾回收

1. 遍历调用栈(变量环境和词法环境),能够访问的对象成为`活动对象`,否则就是`垃圾数据`
2. 清除堆内存中非活动对象

![标记清除](../images/03/mark-sweep.png)

不连续内存碎片问题?

标记清除算法对一块内存多次执行标记清除后,会产生大量不连续内存,分配较大对象时会导致内存不足;由此产生另外一种垃圾回收算法:`标记-整理`

标记整理算法

1. 遍历调用栈(变量环境和词法环境),能够访问的对象成为`活动对象`,否则就是`垃圾数据`
2. 所有存活的对象向同一端移动,然后清除端边界以外的内存;

![标记整理](../images/03/mark-compact.png)

## 全停顿问题

全停顿: JavaScript 运行在主线程上,一旦执行垃圾回收,需要将正在执行的 JavaScript 脚本暂停,垃圾回收执行完毕,再恢复脚本执行;

![全停顿](../images/03/stop-the-world.png)

增量标记算法

将标记过程分为一个个子标记过程,同时让垃圾回收标记和 JavaScript 应用逻辑交替运行,直到标记阶段完成,以降低老生代垃圾回收造成的卡顿;

![增量标记](../images/03/incremental-marking.png)

总结:

1. 垃圾数据容易导致程序运行变慢,所以需要垃圾回收,减少内存占用
2. 基础数据类型存储在栈空间中,引用数据类型存储在堆空间中,不同存储类型的数据垃圾清除的方式不同
3. 栈空间垃圾回收在 ESP 下移过程中就会被标记为无效,下一个执行上下文将覆盖无效的内存空间
4. 堆空间垃圾分为新生代垃圾和老生代垃圾,新生代存储生存周期端的数据,老生代存储生存周期长且数据量大的数据
5. [Scavenge]新生区垃圾分为空闲区域和对象区域,新加入的数据存储在对象区域,对象区域内存不足,副垃圾回收器执行垃圾回收,将垃圾数据做标记,标记完成后,将存活的对象复制到空闲区域并有序的排列起来,然后将空闲区域和对象区域角色翻转,无限复用下去;经历两次垃圾回收依然存储的对象采用晋升策略,移动到老生区中;
6. [标记-清除]主垃圾回收器遍历调用栈,标记存活的对象,清除非活动对象
7. [标记-整理]主垃圾回收器遍历调用栈,标记存活的对象,将所有存活对象向同一端移动,然后清除端边界以外的对象
8. [增量标记-整理]主垃圾回收器将标记过程分为一个个子标记过程,让垃圾回收标记和 JavaScript 脚本运行交替执行,直到标记完成,然后将所有存活对象向同一端移动,然后清除端边界以外的对象
